// scripts/deploy-product-tracking.js
const hre = require("hardhat");
const fs = require('fs');
const path = require('path');

async function main() {
  console.log("ğŸš€ Starting ProductTracking contract deployment...");

  // Get the contract factory
  const ProductTracking = await hre.ethers.getContractFactory("ProductTracking");
  
  // Deploy the contract
  console.log("ğŸ“¦ Deploying ProductTracking contract...");
  const productTracking = await ProductTracking.deploy();
  
  // Wait for deployment to finish
  await productTracking.waitForDeployment();
  
  const contractAddress = await productTracking.getAddress();
  console.log("âœ… ProductTracking contract deployed to:", contractAddress);

  // Get network information
  const network = hre.network.name;
  const chainId = (await hre.ethers.provider.getNetwork()).chainId;
  
  console.log("ğŸŒ Network:", network);
  console.log("ğŸ”— Chain ID:", chainId.toString());

  // Create deployment info
  const deploymentInfo = {
    contractAddress: contractAddress,
    network: network,
    chainId: chainId.toString(),
    deploymentTime: new Date().toISOString(),
    deployer: (await hre.ethers.getSigners())[0].address,
    contractName: "ProductTracking"
  };

  // Save deployment info to file
  const deploymentsDir = path.join(__dirname, '..', 'deployments');
  if (!fs.existsSync(deploymentsDir)) {
    fs.mkdirSync(deploymentsDir, { recursive: true });
  }
  
  const deploymentFile = path.join(deploymentsDir, `product-tracking-${network}.json`);
  fs.writeFileSync(deploymentFile, JSON.stringify(deploymentInfo, null, 2));
  console.log("ğŸ“„ Deployment info saved to:", deploymentFile);

  // Update .env file with contract address
  const envPath = path.join(__dirname, '..', '.env');
  let envContent = '';
  
  if (fs.existsSync(envPath)) {
    envContent = fs.readFileSync(envPath, 'utf8');
  }

  // Update or add the contract address for the current network
  const envKey = `${network.toUpperCase()}_PRODUCT_CONTRACT_ADDRESS`;
  const envLine = `${envKey}=${contractAddress}`;
  
  if (envContent.includes(envKey)) {
    // Replace existing line
    envContent = envContent.replace(
      new RegExp(`${envKey}=.*`), 
      envLine
    );
  } else {
    // Add new line
    envContent += `\n${envLine}`;
  }
  
  fs.writeFileSync(envPath, envContent);
  console.log(`âœ… Updated .env with ${envKey}=${contractAddress}`);

  // Test the deployed contract
  console.log("\nğŸ§ª Testing deployed contract...");
  
  try {
    // Test basic functions
    const totalProducts = await productTracking.getProductCount();
    console.log("ğŸ“Š Initial product count:", totalProducts.toString());
    
    const contractOwner = await productTracking.contractOwner();
    console.log("ğŸ‘¤ Contract owner:", contractOwner);
    
    console.log("âœ… Contract test successful!");
    
  } catch (error) {
    console.log("âŒ Contract test failed:", error.message);
  }

  // Create Flutter environment configuration
  const flutterEnvContent = `
# Blockchain Configuration - Generated by deployment script
# Network: ${network}
# Deployed: ${deploymentInfo.deploymentTime}

ACTIVE_NETWORK=${network}
RPC_URL=${getRpcUrl(network)}
${envKey}=${contractAddress}
CHAIN_ID=${chainId.toString()}

# Contract ABI Hash (for cache invalidation)
PRODUCT_CONTRACT_ABI_HASH=${generateAbiHash()}
`;

  const flutterEnvPath = path.join(__dirname, '..', 'flutter_env.env');
  fs.writeFileSync(flutterEnvPath, flutterEnvContent.trim());
  console.log("ğŸ“± Flutter environment file created:", flutterEnvPath);

  // Generate contract interaction examples
  console.log("\nğŸ“ Contract interaction examples:");
  console.log("=".repeat(50));
  console.log(`
// Register a product
await productTracking.registerProduct(
  "MYA001",                    // Product ID
  "Sustainable Palm Oil",      // Name
  "Palm Oil",                 // Category  
  "SKU-PO-001",              // SKU
  ethers.parseEther("0.1"),   // Price (0.1 ETH)
  1000,                       // Quantity
  "Johor, Malaysia"          // Origin
);

// Verify a product
await productTracking.verifyProduct(
  "MYA001",                   // Product ID
  "Kuala Lumpur, Malaysia",   // Verification location
  250                         // Response time in ms
);

// Get product details
const productDetails = await productTracking.getProductDetails("MYA001");
console.log("Product:", productDetails);
`);

  console.log("=".repeat(50));
  console.log("ğŸ‰ Deployment completed successfully!");
  console.log("\nğŸ“‹ Next steps:");
  console.log("1. Update your Flutter app's .env file with the new contract address");
  console.log("2. Restart your Flutter app to load the new configuration");
  console.log("3. Test product registration and verification in your app");
  console.log("\nğŸ”— Contract Address:", contractAddress);
  console.log("ğŸŒ Network:", network);
  console.log("ğŸ’¾ Verify on Etherscan (if on testnet):", getEtherscanUrl(network, contractAddress));
}

function getRpcUrl(network) {
  switch (network) {
    case 'localhost':
    case 'hardhat':
      return 'http://127.0.0.1:8545';
    case 'sepolia':
      return 'https://sepolia.infura.io/v3/YOUR_INFURA_KEY';
    case 'holesky':
      return 'https://holesky.infura.io/v3/YOUR_INFURA_KEY';
    default:
      return 'http://127.0.0.1:8545';
  }
}

function getEtherscanUrl(network, address) {
  switch (network) {
    case 'sepolia':
      return `https://sepolia.etherscan.io/address/${address}`;
    case 'holesky':
      return `https://holesky.etherscan.io/address/${address}`;
    case 'mainnet':
      return `https://etherscan.io/address/${address}`;
    default:
      return `Local network - no explorer available`;
  }
}

function generateAbiHash() {
  // Simple hash for ABI versioning
  return Date.now().toString(36);
}

// Handle errors
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("âŒ Deployment failed:", error);
    process.exit(1);
  });